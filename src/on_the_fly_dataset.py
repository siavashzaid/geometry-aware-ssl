import torch
from torch.utils.data import IterableDataset, get_worker_info
from torch_geometric.data import Data
from torch_geometric.utils import dense_to_sparse
from acoupipe.datasets.synthetic import DatasetSynthetic
import math

#TODO: fix multi worker functionality 

class OnTheFlyDataset(IterableDataset):
    # --- class level cache for fully connected edge indices ---
    _edge_index_cache_cpu = {}

    def __init__(
        self,
        *,
        # --- Dataset Config ---
        config,
        # --- Generation parameters ---
        features=["csm", "eigmode", "cartesian_coordinates", "loc", "source_strength_analytic"],
        f, #frequency (Hz)
        split, 
        size, 
        num=0, #frequency band width (0 for single freq)
        progress_bar=False,
        start_idx=0, #starting index for generation (useful for parallel workers)
    ):
        super().__init__()
        self.features = features
        self.f = f
        self.split = split
        self.size = int(size)
        self.num = num
        self.progress_bar = progress_bar
        self.start_idx = int(start_idx)
        self.config = config

    def __iter__(self):
        # --- initialize dataset ---
        dataset = DatasetSynthetic(config = self.config)

        # --- parallel worker setup ---
        info = get_worker_info()
        # --- no parallel workers ---
        if info is None:
            start = self.start_idx
            size = self.size
        # --- with parallel workers, split the generation among them ---    
        else:
            per_worker = math.ceil(self.size / info.num_workers) # use size and worker count that are divisible to avoid uneven splits
            start = self.start_idx + info.id * per_worker
            size = per_worker

        # --- define generator per worker---
        gen = dataset.generate(
            features=self.features,
            f = self.f,
            split=self.split,
            size=size,
            num=self.num,
            start_idx=start,
            progress_bar=self.progress_bar,
        )

        # --- yield samples as PyG Data objects ---
        for sample in gen:
            yield self.sample_to_graph(sample)


    # --- utility functions --- 
    @staticmethod
    def sample_to_graph(sample):
        """
        Convert a single AcouPipe-generated sample into a PyTorch Geometric
        Data object.

        Parameters
        ----------
        sample : dict
            Dictionary containing raw features generated by AcouPipe.
            
        Returns
        -------
        torch_geometric.data.Data
            PyTorch Geometric Data object with node features, edge indices, edge attributes, and labels.
      
        """
        # --- load & cast raw features from sample ---
        csm = torch.from_numpy(sample["csm"]).squeeze().to(torch.complex64)          # (N,N), complex64
        eigmode = torch.from_numpy(sample["eigmode"]).to(torch.complex64)           # (N,N), complex64
        eigmode = torch.view_as_real(eigmode).to(torch.float32)                     # (N,N,2), float32

        coords = torch.from_numpy(sample["cartesian_coordinates"]).T.to(torch.float32)  # (N,3), float32
        loc = torch.from_numpy(sample["loc"]).to(torch.float32)                         # (3,nsrc), float32
        source_strength = torch.from_numpy(sample["source_strength_analytic"]).squeeze(0).to(torch.float32) # (nsources,), float32

        # --- normalize raw features ---
        #TODO: check alternative approach normalize autopower by trace and cross spectra by coherence
        csm = csm / torch.trace(csm).real
        source_strength = source_strength / source_strength.sum()

        # --- define node features ---
        theta = torch.atan2(coords[:, 1], coords[:, 0])
        cos_theta, sin_theta = torch.cos(theta), torch.sin(theta) # (N,), float32

        r = torch.sqrt(coords[:, 0]**2 + coords[:, 1]**2) # (N,), float32
        r = r / (r.max() + 1e-8) # normalize radius

        autopower = torch.diagonal(csm) # (N,), complex64
        autopower_real, autopower_imag = autopower.real, autopower.imag # (N,), float32

        #TODO: implement positional encoding (Min-Sang Baek, Joon-Hyuk Chang, and Israel Cohen) 

        # --- define adjacency ---
        N = coords.size(0)
        edge_index = OnTheFlyDataset.fully_connected_edges(N) # (2, E), cached, no self-loops
        src, dst = edge_index # (E,), (E,)

        # --- define edge features ---
        cross_spectra = csm[src, dst] # (E, 1), complex64
        cross_spectra_real, cross_spectra_imag = cross_spectra.real, cross_spectra.imag # (E, 1), float32

        dx = coords[dst, 0] - coords[src, 0]
        dy = coords[dst, 1] - coords[src, 1]
        dist = torch.sqrt(dx**2 + dy**2 + 1e-8) # (E, 1), float32

        unit_direction_x, unit_direction_y = dx / dist, dy / dist # (E, 1), float32 

        cos_sim = cos_theta[src] * cos_theta[dst] + sin_theta[src] * sin_theta[dst] # (E, 1), float32, computed with trigonometric identity

        # --- build feature vectors ---
        x = OnTheFlyDataset.build_feature(coords, r, cos_theta, sin_theta, autopower_real, autopower_imag, dim=1)
        edge_attr = OnTheFlyDataset.build_feature(cross_spectra_real, cross_spectra_imag, dist, unit_direction_x, unit_direction_y, cos_sim, dim=1)

        # ---  define eigmode tokens analog to Kujawaski et. al---
        eigmode = torch.cat(
            [
                torch.cat([eigmode[..., 0], -eigmode[..., 1]], dim=-1),
                torch.cat([eigmode[..., 1],  eigmode[..., 0]], dim=-1),
            ],
            dim=-2,
        )

        # --- labels ---
        idx = torch.argmax(source_strength) # strongest source index
        y = loc[:, idx][:2].unsqueeze(0).unsqueeze(0)  # [B,1,2]
        strength = source_strength[idx].unsqueeze(0).unsqueeze(0) # [B, 1]

        # --- build PyG Data object ---
        data = Data(
            x=x, 
            edge_index=edge_index, 
            edge_attr=edge_attr, 
            y=y)
        
        data.strength = strength
        #data.eigmode = eigmode

        return data

    @staticmethod
    def build_feature(*feats, dim=-1):
        """
        Utility function to construct a feature tensor from multiple inputs.

        Parameters
        ----------
        *feats : torch.Tensor
            Feature tensors to be combined. Must be broadcast-compatible
            except for the concatenation dimension.
        dim : int, optional
            Dimension along which to concatenate the features (default: -1).

        Returns
        -------
        torch.Tensor
            Concatenated feature tensor.
        """
        feats = [feature.unsqueeze(-1) if feature.dim() == 1 else feature for feature in feats]
        return torch.cat(feats, dim=dim)
    
   
    @staticmethod
    def fully_connected_edges(N):
        """
        Construct a fully connected graph adjacency without self-loops and
        cache the result for efficiency.

        Parameters
        ----------
        N : int
            Number of nodes (e.g., microphones) in the graph.

        Returns
        -------
        torch.Tensor
            Edge index tensor of shape (2, E),
            containing all directed edges without self-loops.
        """
        cached = OnTheFlyDataset._edge_index_cache_cpu.get(N)
        if cached is not None:
            return cached

        adj = torch.ones(N, N, dtype=torch.bool)
        adj.fill_diagonal_(False)
        edge_index = dense_to_sparse(adj)[0].contiguous()
        OnTheFlyDataset._edge_index_cache_cpu[N] = edge_index
        return edge_index